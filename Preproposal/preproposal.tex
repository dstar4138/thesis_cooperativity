\documentclass[11pt]{artikel3}
\usepackage{fullpage, setspace, graphicx}
\usepackage[margin=1in]{geometry}
\usepackage{times}
\usepackage{enumitem}

\title{RIT Department of Computer Science\\MSc Thesis Pre-Proposal:\\
	%\emph{Interactivity of Cooperating Processes}
	%\emph{Cooperativity of Processes as a Feedback Metric in Functional Languages}
	\emph{Process Cooperativity as a Feedback Metric in Functional Languages}
}
\author{Alexander Dean, Chair: Matthew Fluet}
\date{\today}

\begin{document}
\maketitle

\section{Problem Description}

Runtime systems for functional languages have begun to utilize feedback mechanisms to influence their 
scheduling behaviour as the application proceeds. These feedback mechanisms rely on metrics by which to 
grade any alterations made to the runtime system. As the application's phase shifts, the feedback mechanism
is tasked with modifying the runtime to reduce it's overhead and increase the application's efficiency.

For example, feedback mechanism could utilize the ratio of I/O to CPU bound processes within a set number 
of rounds to be the metric by which it grades it's efficiency. If it is too high the runtime should give
each process less time to compute, so it can get through more processes in a round, thus reducing the drag
the CPU bound processes have on the system. The inverse would have the opposite effect.

Cooperativity is another possible metric by which to grade a system. In biochemistry the term cooperativity 
is defined as the increase or decrease in the rate of interaction between a reactant and a protein as 
the reactant concentration increases. This definition translates well as an information theoretic definition 
as: the increase or decrease in the rate of interaction between a process and a communication mode as the 
number of processes increase.

%Communication mode in this sense would be a function of interprocess communication such as
%asynchronous mail-boxes, synchronous channel or even shared memory. In any example the sending process will 
%need to interact with this method as a means of interacting with a concurrent process.

I will attempt to answer the following questions:
\begin{itemize}[leftmargin=.5in]
	\item Are the abstractions of a process and communication channel conducive to quantifying cooperativity of a system? What generalizations can be made without obscuring important factors?
	\item What factors effect the cooperativity of a runtime system? Also, what mechanisms can be used to update the runtime system to positively improve cooperativity in a given phase?
	\item Is cooperativity a comparable metric for feedback scheduling?
\end{itemize}

\section{Related Work}

Scheduling based on feedback from the running system is not new \cite{dietz1997use}. There have even been multiple 
metrics explored, such as heap size \cite{white2012automated}, process locality \cite{debattista2002cache}, and interactivity \cite{reppy1993concurrent}. 
In \cite{ritson2012multicore} they mention communication efficiency as a rational for their implementation of a runtime scheduler using process locality 
as the primary metric. However, this differs from capturing the cooperativity in that, while communication efficiency is important, it misses the quantity 
of communication which could indicate needed changes in scheduling quantum.

\section{Motivation}

Runtime scheduler's introduce overhead which manifests itself by the act of context switching and the extra metric evaluation. Minimizing this overhead is the goal of any good runtime system

\section{Evaluation}

* What software: Current compilers do not open themselves up to ease of experimentation. To compensate, I will need to build a custom compiler with the ability to monitor itself and the capability of swapping schedulers at runtime so as to do some initial comparative analysis. 

* What Metrics: In order to classify 

\section{Evaluation Outcomes}

 * Develop a metric of cooperativity and interactivity in a running system.
 
 * Utilize the metric as a feedback mechanism of a runtime scheduler.
 
 * Compare scheduling efficiency against alternative metrics and scheduler designs.

\nocite{*}
\bibliographystyle{plain}
\bibliography{preproposal}

\end{document}
