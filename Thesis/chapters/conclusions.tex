\chapter{Conclusion and Future Work}
\index{Conclusion and Future Work@\emph{Conclusion and Future Work}}%
\label{chap:conclusions}

\section{Utility of the ErLam Toolkit}\label{sec:conclusions-erlam}

To test our scheduling mechanisms, the ErLam Toolkit provided a powerful framework
for their implementation and execution observation. The testing primitives provided
provide a concise way to reference common behavior and subsequently compare 
executions. The logging system was also precise enough to allow for further 
statistical comparison between multiple runs of the same test case. This allowed 
for easier fine-tuning as well as general algorithm debugging.

\section{Effectiveness of Cooperativity as a Metric}
\label{sec:conclusions-cooperativity}

Our original goal was to show several potentially adventagious mechanisms 
schedulers could use to take advantage of process cooperativity. We believe that 
we were able to validate most of our hypotheses and show that cooperativity can
be a powerful metric by which to govern a scheduler. With analysis of multiple 
test cases including boundary and common conditions, we proved the practicality of
these mechanisms as well. Ultimately we were able to open more avenues of possible
research in this field that we hope to explore further.

\section{Future Work}\label{sec:future-work}

There are a number of appealing avenues of improvement for the ErLam Toolkit. The
report generation mechanism could be extended and tied into the logging system a 
bit more  closely. For example, the implementation of a real-time viewer would be an 
interesting extension. Also, there are obviously a larger number of metrics which may lead
to better cooperativity classifications as well. It may be more fruitful, for 
example, to keep track of communication partners rather than channel names. 
The core language is also an appealing simulation implementation language, as such, a 
larger library of testing primitives would benefit the language designer community 
greatly. Furthermore, a complete catalog of parameterized executions would also aid 
in analysis and scheduler comparison.

In terms of cooperativity as a feedback metric, it would be interesting to further
tweak the three cooperativity-conscious schedulers already implemented. Perhaps 
composing the scheduler mechanics themselves may lead to a more robust algorithm.
For example, the combination of the Batching and Channel Pinning may lead to a better
work stealing mechanism as batches now belong to channels. Alternatively the ability
to sort batches might speed up the sorting process. It would also reduce the search
space for finding related processes when it came time to re-sort. However, in short, 
the future of cooperativity as a feedback metric looks promising.

